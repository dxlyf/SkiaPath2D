import { Ref } from './util';
export declare class Point {
    static zero(): Point;
    static default(): Point;
    static create(x: number, y: number): Point;
    static fromPoint(p: {
        x: number;
        y: number;
    }): Point;
    static fromRotation(r: number): Point;
    static fromXY(x: number, y: number): Point;
    static splat(x: number): Point;
    static make(num: number): Point[];
    elements: Float32Array;
    constructor(elements: number[] | Float32Array);
    isVector2: boolean;
    get x(): number;
    set x(x: number);
    get y(): number;
    set y(y: number);
    get halfX(): number;
    get halfY(): number;
    set(x: number, y: number): this;
    clone(): Point;
    copy(p: Point): this;
    add(p: Point): this;
    addVectors(v1: Point, v2: Point): this;
    subtractVectors(v1: Point, v2: Point): this;
    sub(p: Point): this;
    subtract(p: Point): this;
    negate(): this;
    inverse(): this;
    multiplyScalar(s: number): this;
    multiplyVectorScalar(v: Point, s: number): this;
    subtractMultiplyVectorScalar(a: Point, v: Point, s: number): this;
    addMultiplyVectorScalar(a: Point, v: Point, s: number): this;
    multiplySubtractVectors(v1: Point, v2: Point): this;
    multiplyAddVectors(v1: Point, v2: Point): this;
    multiplyVectors(v1: Point, v2: Point): this;
    multiply(p: Point): this;
    divideVectors(v1: Point, v2: Point): this;
    divideScalar(s: number): this;
    divide(p: Point): this;
    dot(v: Point): number;
    cross(v: Point): number;
    perp(): this;
    rperp(): this;
    canNormalize(): boolean;
    toNormalize(): this;
    normalize(): boolean;
    setNormalized(v: Point): boolean;
    distanceToSquared(v: Point): number;
    distanceTo(v: Point): number;
    manhattanDistanceTo(v: Point): number;
    lengthSquared(): number;
    lengthSq(): number;
    length(): number;
    inverseLength(): number;
    angle(): number;
    angleTanTo(v: Point): number;
    angleTo(v: Point): number;
    projectLength(v: Point): number;
    projectLengthNormalize(normalize: Point): number;
    projectRatio(v: Point): number;
    project(v: Point): this;
    projectNormalize(normalize: Point): this;
    reflect(normalize: Point): this;
    translate(x: number, y: number): this;
    rotate(angle: number, origin?: Point): this;
    scale(x: number, y: number): this;
    round(): this;
    abs(): this;
    ceil(): this;
    floor(): this;
    trunc(): this;
    sign(): this;
    cosSin(): this;
    minScalar(s: number): this;
    minVectors(v1: Point, v2: Point): this;
    maxVectors(v1: Point, v2: Point): this;
    min(p: Point): this;
    max(p: Point): this;
    lerp(s: Point, v: Point, t: number): this;
    smoonstep(s: Point, v: Point, t: number): this;
    setPointLength(pt: Point, x: number, y: number, length: number, orig_length?: Ref): boolean;
    setLength(len: number): boolean;
    setLengthFrom(x: number, y: number, length: number): boolean;
    isFinite(): boolean;
    isZero(): boolean;
    isOne(): boolean;
    equals(v: Point): boolean;
    equalsEpsilon(v: Point, epsilon?: number): boolean;
    applyMatrix2D(matrix: any): this;
    cw(): this;
    ccw(): this;
}
export declare class Point3D {
    static default(): Point3D;
    static make(count: number): Point3D[];
    static create(x?: number, y?: number, z?: number): Point3D;
    elements: Float32Array<ArrayBuffer>;
    constructor(x?: number, y?: number, z?: number);
    get x(): number;
    set x(v: number);
    get y(): number;
    set y(v: number);
    get z(): number;
    set z(v: number);
    set(x: number, y: number, z: number): this;
    clone(): Point3D;
    copy(v: Point3D): this;
}
