import { Point } from './point';
export declare class Matrix2D {
    static EPSILON: number;
    static IDENTITY_MATRIX: Matrix2D;
    static identity(): Matrix2D;
    static default(): Matrix2D;
    static fromSinCos(sin: number, cos: number): Matrix2D;
    static fromSinCosOrigin(sin: number, cos: number, x: number, y: number): Matrix2D;
    static fromTranslation(x: number, y: number): Matrix2D;
    static fromTranslate(x: number, y: number): Matrix2D;
    static fromRotation(theta: number): Matrix2D;
    static fromRotate(radian: number): Matrix2D;
    static fromRotateOrigin(radian: number, x: number, y: number): Matrix2D;
    static fromRotateDegrees(degrees: number): Matrix2D;
    static fromScale(sx: number, sy: number): Matrix2D;
    static fromScaleAxis(n: Point, k: number): Matrix2D;
    static fromSkew(kx: number, ky: number): Matrix2D;
    static fromArray(elements: Float32Array | number[], mutable?: boolean): Matrix2D;
    static fromRows(a: number, b: number, c: number, d: number, e: number, f: number): Matrix2D;
    static pools: Matrix2D[];
    static poolSize: number;
    static pool(): Matrix2D;
    static release(instance: Matrix2D): void;
    isMatrix2D: boolean;
    elements: Float32Array;
    mutable: boolean;
    constructor(elements: Float32Array | number[], mutable?: boolean);
    get a(): number;
    get b(): number;
    get c(): number;
    get d(): number;
    get e(): number;
    get f(): number;
    pool(): Matrix2D;
    release(): void;
    setMutable(mutable: boolean): this;
    identity(): Matrix2D;
    set(a: number, b: number, c: number, d: number, e: number, f: number): Matrix2D;
    setElements(elements: Float32Array | number[]): Matrix2D;
    clone(): Matrix2D;
    copy(other: Matrix2D): this;
    isIdentity(): boolean;
    isZero(): boolean;
    isFinite(): boolean;
    isTranslate(): boolean;
    isScale(): boolean;
    isRotation(): boolean;
    isScaleTranslate(): boolean;
    isScaleRotate(): boolean;
    hasScale(): boolean;
    hasTranslate(): boolean;
    hasRotation(): boolean;
    floor(): Matrix2D;
    ceil(): Matrix2D;
    multiply(m: Matrix2D): Matrix2D;
    premultiply(m: Matrix2D): Matrix2D;
    multiplyMatrices(left: Matrix2D, right: Matrix2D): Matrix2D;
    multiplyScalar(s: number): Matrix2D;
    setScale(sx: number, sy: number): Matrix2D;
    setSinCos(sinV: number, cosV: number): this;
    setSinCos(sinV: number, cosV: number, px: number, py: number): this;
    setRotate(radian: number): this;
    setRotate(radian: number, x: number, y: number): this;
    setRotateDegrees(radian: number): this;
    setTranslate(tx: number, ty: number): Matrix2D;
    preScale(sx: number, sy: number): Matrix2D;
    postScale(sx: number, sy: number): Matrix2D;
    preRotate(angle: number): Matrix2D;
    preRotateDegrees(angle: number): Matrix2D;
    postRotate(angle: number): Matrix2D;
    postRotateDegrees(angle: number): Matrix2D;
    preTranslate(tx: number, ty: number): Matrix2D;
    postTranslate(tx: number, ty: number): Matrix2D;
    fromTranslateRotationSkewScalePivot(translate: Point, rotation: number, skew: Point, scale: Point, pivot: Point): Matrix2D;
    determinant(): number;
    invertMatrix(matrix: Matrix2D): Matrix2D;
    invert(): Matrix2D;
    scale(sx: number, sy: number): Matrix2D;
    rotate(theta: number): Matrix2D;
    translate(tx: number, ty: number): Matrix2D;
    /***
 * 伴随矩阵，先转置，再求余子式
 */
    adjoint(): Matrix2D;
    mapPoints(outPoints: Point[], srcPoints: Point[]): this;
    mapPoint(out: Point, src: Point): Point;
    mapXY(x: number, y: number, out: Point): void;
    projection(width: number, height: number): Matrix2D;
    equals(matrix: Matrix2D): boolean;
    equalsEpsilon(matrix: Matrix2D, epsilon?: number): boolean;
    fromArray(array: number[] | Float32Array, offset?: number): this;
    toArray(array?: number[] | Float32Array, offset?: number): number[] | Float32Array<ArrayBufferLike>;
}
